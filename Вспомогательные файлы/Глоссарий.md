# Глоссарий
## Общие термины разработки и инфраструктуры

### **Docker**
**Определение:** Платформа для создания, развёртывания и управления приложениями в изолированных средах — контейнерах.

**Принципы работы:**
- Использует технологию контейнеризации для изоляции приложений и их зависимостей
- Контейнеры работают поверх единого ядра операционной системы, что делает их легковесными
- Основан на образах — неизменяемых шаблонах с файловой системой и настройками

**Основные компоненты:**
- **Docker Engine:** Движок для создания и управления контейнерами
- **Docker Image:** Образ приложения со всеми зависимостями
- **Dockerfile:** Файл-инструкция для сборки образа
- **Docker Hub:** Реестр для хранения и обмена образами

**Инструменты:**
- Docker Compose (оркестрация многоконтейнерных приложений)
- Docker Swarm (кластеризация)
- Portainer (GUI для управления)

---

### **Стек (Stack)**
**Определение:** Структура данных, в которой элементы добавляются и извлекаются по принципу «последним пришёл — первым ушёл» (LIFO).

**Принципы работы:**
- Имеет одну точку входа/выхода — вершину стека
- Поддерживает две основные операции: push (добавление) и pop (извлечение)
- Часто реализуется на основе массива или связного списка

**Основные виды:**
- **Стек вызовов (Call Stack):** Для хранения информации о вызовах функций
- **Стек выражений:** Для вычисления арифметических выражений
- **Стек памяти:** Для динамического выделения памяти

**Реализации:**
- Встроенные структуры данных в языках (Stack в Java, list в Python)
- Ручная реализация на массивах или связных списках

---

### **ER-диаграмма (Entity-Relationship)**
**Определение:** Графическая модель, представляющая структуру данных системы через сущности, их атрибуты и связи между ними.

**Принципы работы:**
- Использует три основных компонента: сущности, атрибуты и отношения
- Сущности представляют объекты предметной области
- Атрибуты описывают свойства сущностей
- Отношения показывают связи между сущностями

**Основные виды нотаций:**
- **Нотация Чена:** Классическая нотация с прямоугольниками, ромбами и овалами
- **Нотация Мартина (Crow's Foot):** Современная нотация с разными типами связей
- **UML нотация:** Использование классов и ассоциаций

**Инструменты проектирования:**
- **Профессиональные:** ERwin, IBM InfoSphere Data Architect
- **Бесплатные:** Draw.io, Lucidchart, dbdiagram.io
- **Встроенные:** MySQL Workbench, pgAdmin

---

### **API (Application Programming Interface)**
**Определение:** Набор протоколов, правил и инструментов, позволяющий различным программам взаимодействовать друг с другом.

**Принципы работы:**
- Определяет формат запросов и ответов между системами
- Использует стандартные протоколы передачи данных (HTTP, WebSocket)
- Предоставляет абстракцию над внутренней реализацией системы

**Основные виды API:**
- **REST API:** На основе HTTP-методов и ресурсов
- **SOAP API:** На основе XML и строгих стандартов
- **GraphQL:** Гибкий язык запросов для API
- **gRPC:** Высокопроизводительный RPC-фреймворк
- **WebSocket API:** Для двусторонней связи в реальном времени

**Технологии и инструменты:**
- **Протоколы:** HTTP/HTTPS, WebSocket, gRPC
- **Форматы данных:** JSON, XML, Protocol Buffers
- **Инструменты тестирования:** Postman, Insomnia, Swagger
- **Документирование:** OpenAPI/Swagger, RAML, API Blueprint

---

### **CRUD-эндпоинт**
**Определение:** URL-адрес в API, предназначенный для выполнения четырёх базовых операций с данными: создания, чтения, обновления и удаления.

**Принципы работы:**
- Каждая операция соответствует определённому HTTP-методу
- Использует RESTful принципы проектирования
- Работает с ресурсами как с объектами

**Базовые операции:**
- **C (Create):** POST /ресурс — создание нового ресурса
- **R (Read):** GET /ресурс — получение ресурса(ов)
- **U (Update):** PUT/PATCH /ресурс/{id} — обновление ресурса
- **D (Delete):** DELETE /ресурс/{id} — удаление ресурса

**Паттерны реализации:**
- Контроллеры в MVC-архитектуре
- Сервисные классы в многослойной архитектуре
- GraphQL мутации и запросы

**Инструменты:**
- Фреймворки: Express.js (Node.js), Django REST (Python), Spring Boot (Java)
- Генераторы: Swagger Codegen, OpenAPI Generator

---

### **CORS (Cross-Origin Resource Sharing)**
**Определение:** Механизм безопасности, разрешающий веб-страницам делать запросы к серверам на других доменах.

**Принципы работы:**
- Браузер отправляет предварительный запрос OPTIONS для проверки разрешений
- Сервер возвращает заголовки с политиками доступа
- При соответствии политикам выполняется основной запрос

**Основные заголовки CORS:**
- **Access-Control-Allow-Origin:** Разрешенные источники
- **Access-Control-Allow-Methods:** Разрешенные HTTP-методы
- **Access-Control-Allow-Headers:** Разрешенные заголовки запроса
- **Access-Control-Allow-Credentials:** Разрешение на отправку cookies

**Типы запросов:**
- **Простые запросы:** GET, POST, HEAD с простыми заголовками
- **Предварительные запросы (Preflight):** OPTIONS запрос перед сложными операциями

**Настройка на сервере:**
- **Node.js:** Пакеты cors, helmet
- **Python:** Flask-CORS, django-cors-headers
- **Java:** Spring Security CORS configuration
- **Nginx:** Конфигурация через proxy_pass

---

### **Коллекции запросов к API**
**Определение:** Упорядоченные наборы HTTP-запросов, сгруппированные для удобства тестирования и автоматизации.

**Принципы работы:**
- Сохраняют параметры запросов (URL, заголовки, тело)
- Позволяют определять переменные и окружения
- Поддерживают цепочки запросов и зависимые тесты

**Основные возможности:**
- Организация запросов в папки и подпапки
- Автоматизация через скрипты (JavaScript)
- Параметризация с переменными окружения
- Генерация документации

**Популярные инструменты:**
- **Postman:** Наиболее популярный, с командной строкой Newman
- **Insomnia:** Открытый аналог с акцентом на простоту
- **Bruno:** Открытая альтернатива с локальным хранением
- **HTTPie:** CLI-инструмент для API
- **Thunder Client:** Расширение VS Code

---

### **Fetch API**
**Определение:** Современный JavaScript-интерфейс для выполнения HTTP-запросов, встроенный в браузеры.

**Принципы работы:**
- Возвращает Promise для асинхронной обработки
- Использует стандартные объекты Request и Response
- Поддерживает все основные HTTP-методы

**Основные методы:**
- `fetch(url, options)` — основной метод
- `response.json()` — парсинг JSON-ответа
- `response.text()` — получение текстового ответа
- `response.blob()` — работа с бинарными данными

**Преимущества над XMLHttpRequest:**
- Цепочки Promise и async/await
- Более чистый и понятный синтаксис
- Встроенная поддержка Streams API
- Лучшая обработка ошибок

**Особенности:**
- По умолчанию не отправляет cookies
- Не обрабатывает HTTP-ошибки как исключения (только сетевые)
- Требует ручного парсинга ответов

---

### **Axios**
**Определение:** JavaScript-библиотека для выполнения HTTP-запросов в браузере и Node.js.

**Принципы работы:**
- Основана на Promise API
- Автоматически преобразует данные JSON
- Предоставляет перехватчики (interceptors) для запросов и ответов

**Основные особенности:**
- Автоматический парсинг JSON-ответов
- Автоматическая обработка HTTP-ошибок (коды 4xx, 5xx)
- Поддержка отмены запросов
- Защита от XSRF
- Поддержка прогресса загрузки

**Сравнение с Fetch API:**
- **Axios:** Автоматический JSON, обработка ошибок, браузерная совместимость
- **Fetch:** Нативный API, Streams, Service Workers

---

### **Парсинг данных**
**Определение:** Автоматизированный процесс извлечения и структурирования информации из различных источников.

**Принципы работы:**
- Анализ структуры исходных данных
- Извлечение нужных элементов по шаблонам
- Преобразование в требуемый формат
- Сохранение или дальнейшая обработка

**Основные виды парсинга:**
- **Веб-парсинг (Web Scraping):** Извлечение данных с веб-страниц
- **Парсинг документов:** Работа с PDF, Word, Excel
- **Парсинг API:** Обработка JSON/XML ответов
- **Парсинг логов:** Анализ файлов журналов

**Технологии и инструменты:**
- **Библиотеки Python:** BeautifulSoup, Scrapy, Selenium
- **Node.js:** Cheerio, Puppeteer, Playwright
- **Браузерные расширения:** Web Scraper, Data Miner
- **Готовые решения:** ParseHub, Octoparse

**Законность и этика:**
- Проверка robots.txt
- Соблюдение условий использования
- Ограничение частоты запросов
- Использование публичных API при наличии

---

### **Рефакторинг кода**
**Определение:** Процесс улучшения внутренней структуры кода без изменения его внешнего поведения.

**Принципы работы:**
- Серия небольших, безопасных изменений
- Постоянное тестирование для сохранения функциональности
- Следование принципам чистого кода (Clean Code)

**Основные виды рефакторинга:**
- **Извлечение метода/функции:** Выделение повторяющегося кода
- **Переименование:** Улучшение читаемости имен
- **Упрощение условий:** Замена сложных условий
- **Замена алгоритма:** Выбор более эффективного алгоритма
- **Декомпозиция классов:** Разделение больших классов

**Техники и подходы:**
- **Красный-зелёный-рефакторинг (TDD):** В рамках тесто-ориентированной разработки
- **Рефакторинг по запахам кода:** Поиск и устранение антипаттернов
- **Инкрементальный рефакторинг:** Постепенное улучшение в процессе разработки

**Инструменты:**
- **IDE:** Встроенные возможности в VS Code, IntelliJ IDEA, PyCharm
- **Анализаторы кода:** SonarQube, ESLint, Pylint
- **Инструменты рефакторинга:** jscodeshift (JavaScript), rope (Python)
- **Системы контроля версий:** Git для отслеживания изменений

---

### **FastAPI**
**Определение:** Современный, высокопроизводительный веб-фреймворк для создания API на языке Python, основанный на стандартах OpenAPI и JSON Schema.

**Принципы работы:**
- Использует аннотации типов Python (type hints) для автоматической валидации данных, сериализации и генерации документации.
- Работает асинхронно (поддерживает `async`/`await`), что позволяет обрабатывать множество одновременных запросов.
- Автоматически генерирует интерактивную документацию API (Swagger UI и ReDoc).

**Ключевые особенности:**
- **Высокая производительность:** Сопоставим с Node.js и Go благодаря использованию Starlette (для веб-части) и Pydantic (для данных).
- **Простота кода:** Минимальный шаблонный код, логика описывается ясно и прямо.
- **Встроенная валидация данных:** Через интеграцию с **Pydantic**.
- **Зависимости (Dependencies):** Мощная система для внедрения зависимостей, управления доступом и повторного использования кода.

**Основные компоненты в контексте УП.01:**
- **Pydantic-модели:** Для определения структуры данных запросов и ответов, обеспечивают валидацию.
- **SQLAlchemy-модели:** Для описания таблиц базы данных и работы с ними через ORM.
- **CRUD-эндпоинты:** Создаются с помощью декораторов `@app.get`, `@app.post` и т.д.

---

### **Nest.JS**
**Определение:** Прогрессивный фреймворк для создания эффективных и масштабируемых серверных приложений на Node.js, использующий TypeScript и вдохновленный архитектурой Angular.

**Принципы работы:**
- Строго следует архитектурному шаблону **модульности** и широко использует **внедрение зависимостей (Dependency Injection)**.
- Приложения структурированы в виде набора модулей, контроллеров, сервисов и провайдеров.
- Предоставляет «из коробки» решение для организации кода, что облегчает разработку и поддержку крупных проектов.

**Основные архитектурные элементы:**
- **Модули (Modules):** Классы с декоратором `@Module()`, организуют структуру приложения.
- **Контроллеры (Controllers):** Обрабатывают входящие HTTP-запросы и возвращают ответы клиенту.
- **Сервисы (Providers/ Services):** Содержат бизнес-логику, инжектируются в контроллеры.
- **Мидлвары (Middleware), Фильтры исключений (Exception Filters), Guard's (стражи):** Для обработки запросов на разных этапах.

**Применение в УП.01:** Один из вариантов для разработки **клиентской части (Frontend)** в виде полноценного серверного рендеринга или для создания структурированного backend-микросервиса.

---

### **ORM (Object-Relational Mapping / Объектно-реляционное отображение)**
**Определение:** Технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных».

**Принципы работы:**
- Позволяет разработчикам работать с данными из БД как с обычными объектами и классами в коде (например, `task.title = "Новая"`, затем `task.save()`).
- ORM-библиотека автоматически преобразует операции над объектами в SQL-запросы (SELECT, INSERT, UPDATE, DELETE).

**Преимущества:**
- **Повышение продуктивности:** Меньше ручного написания SQL.
- **Безопасность:** Снижение риска SQL-инъекций за счет использования параметризованных запросов.
- **Абстракция от БД:** Упрощение миграции между разными СУБД (PostgreSQL, MySQL, SQLite).
- **Удобство:** Работа с данными в стиле родного языка программирования.

**Примеры ORM:**
- **SQLAlchemy, SQLModel, Peewee, Django ORM** (Python).
- **TypeORM, Prisma, Sequelize** (Node.js / TypeScript).
- **Hibernate** (Java), **Entity Framework** (C#).

**В контексте УП.01:** Использование **SQLAlchemy** в связке с FastAPI для работы с PostgreSQL.

---

### **Pydantic**
**Определение:** Библиотека Python для валидации данных и управления настройками на основе аннотаций типов.

**Принципы работы:**
- Определяет модели данных как классы, наследующиеся от `BaseModel`.
- Автоматически проверяет типы и преобразует входящие данные (из JSON, форм и т.д.) в экземпляры этих классов.
- При несоответствии данных ожидаемой схеме вызывает понятные ошибки валидации.

**Роль в FastAPI:**
- **Валидация запросов и ответов:** Pydantic-модели используются для определения схемы тела запроса (`request.body`), параметров пути (`path parameters`) и ответа (`response_model`).
- **Сериализация:** Автоматическое преобразование объектов Python (например, из SQLAlchemy) в JSON для ответа API.
- **Генерация документации:** FastAPI использует схемы Pydantic для автоматического описания API в Swagger/OpenAPI.

**В контексте УП.01:** Создание моделей для сущностей (например, "Задача"), которые гарантируют, что API получает и возвращает данные корректного формата.

---

### **Aiogram**
**Определение:** Асинхронный фреймворк для создания Telegram-ботов на Python, позволяющий эффективно обрабатывать множество событий одновременно.

**Принципы работы:**
- Построен на принципах **асинхронного программирования** (`asyncio`), что делает его очень производительным.
- Использует систему **FSM (Finite State Machine / Конечный автомат)** для управления состоянием диалога с пользователем (например, пошаговое создание задачи).
- Имеет четкую структуру: **диспетчер (Dispatcher)** для регистрации обработчиков, **роутеры (Routers)** для организации кода.

**Основные компоненты:**
- **Обработчики (Handlers):** Функции, декорированные `@dp.message()`, `@dp.callback_query()` и т.д., которые реагируют на определенные типы событий.
- **Фильтры (Filters):** Условия, при которых должен сработать обработчик (например, `commands=["start"]`, `state="waiting_for_title"`).
- **Клавиатуры (Keyboards):** Инструменты для создания `ReplyKeyboardMarkup` (обычная клавиатура) и `InlineKeyboardMarkup` (кнопки под сообщением).

**В контексте УП.01:** Инструмент для реализации Telegram-бота, который будет выступать в качестве клиента, отправляющего `fetch`/`axios`-запросы к разработанному FastAPI.

---

### **asyncpg**
**Определение:** Высокопроизводительная асинхронная клиентская библиотека для работы с СУБД PostgreSQL из Python.

**Принципы работы:**
- Написана на Cython и напрямую взаимодействует с протоколом PostgreSQL, что делает её очень быстрой.
- Полностью поддерживает асинхронный доступ к базе данных через `async`/`await`, идеально сочетается с асинхронными фреймворками, такими как FastAPI.
- Не является ORM, а предоставляет эффективный низкоуровневый доступ для выполнения сырых SQL-запросов.

**Преимущества:**
- **Скорость:** В 2-3 раза быстрее синхронных драйверов (например, `psycopg2`) для асинхронных приложений.
- **Легковесность:** Минимальные накладные расходы.
- **Асинхронность:** Позволяет выполнять множественные запросы к БД без блокировки основного потока.

**В контексте УП.01:** Один из возможных драйверов для подключения FastAPI-приложения к PostgreSQL, особенно при работе с асинхронными сессиями SQLAlchemy.

---

### **Интеграционное (сквозное) тестирование (Integration / E2E Testing)**
**Определение:** Уровень тестирования программного обеспечения, при котором отдельные модули или компоненты приложения объединяются и тестируются как группа.

**Принципы работы:**
- Проверяет взаимодействие между различными частями системы (например, между API, базой данных и клиентским приложением).
- Воспроизводит реальные пользовательские сценарии «от начала до конца» (End-to-End).
- Часто требует развертывания приложения в тестовом окружении, близком к боевому.

**Цели:**
- Выявить дефекты в интерфейсах и взаимодействии между интегрированными модулями.
- Убедиться, что вся система работает как единое целое и соответствует требованиям.
- Проверить интеграцию с внешними системами (например, API Telegram).

**Методы:**
- **«Снизу вверх» (Bottom-Up):** Сначала тестируются низкоуровневые модули, затем постепенно подключаются высокоуровневые.
- **«Сверху вниз» (Top-Down):** Начинается с высокоуровневых модулей, заглушки заменяются реальными.
- **«Большой взрыв» (Big Bang):** Все модули интегрируются одновременно, после чего проводится глобальное тестирование.

**В контексте УП.01:** Проводится на **4-й неделе** для проверки полного цикла работы системы: действие в клиенте (веб-интерфейсе или боте) → запрос к FastAPI → изменение в PostgreSQL → корректный ответ обратно клиенту.

---

### **Модульное тестирование (Unit Testing)**
**Определение:** Уровень тестирования, направленный на проверку корректности работы отдельных, изолированных частей исходного кода программы — модулей (функций, методов, классов).

**Принципы работы:**
- Каждый тест проверяет одну конкретную функцию или метод при различных входных данных.
- Модули тестируются **изолированно** от остальной системы: внешние зависимости (база данных, API, файловая система) заменяются **заглушками (mocks)** или **фейками (fakes)**.
- Автоматизировано и выполняется быстро, что позволяет запускать сотни тестов за секунды.

**Цели:**
- Обнаружить дефекты на ранних этапах разработки.
- Обеспечить уверенность в том, что отдельные компоненты работают правильно.
- Облегчить **рефакторинг** — при наличии тестов можно изменять код, не боясь сломать существующую функциональность.

**Инструменты в Python:**
- **pytest:** Самый популярный фреймворк для тестирования, рекомендованный в УП.01. Простой синтаксис, мощные фикстуры (`fixtures`), множество плагинов.
- **unittest:** Стандартный модуль Python для тестирования.

**В контексте УП.01:** На **4-й неделе** студенты пишут модульные тесты для ключевых функций своего API (например, для сервисов, работающих с задачами), используя `pytest` и моки для базы данных.